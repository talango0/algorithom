package leetcode.程序员面试金典;
//给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。
//
//返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。
//
//注意：本题相对书上原题稍作改动
//
//示例：
//
//输入：
//[
//   [-1,0],
//   [0,-1]
//]
//
//输出：[0,1,0,1]
//解释：输入中标粗的元素即为输出所表示的矩阵
//说明：
//
//1 <= matrix.length, matrix[0].length <= 200
//Related Topics
//
//👍 157, 👎 0

import leetcode.dp._53_最大子数组和;

/**
 * @author mayanwei
 * @date 2022-08-23.
 * @see _53_最大子数组和
 */
public class _17_24_最大子矩阵{
    class Solution{
        /**
         * 降维打击+连续子序列的和的最大值
         * <pre>
         *     [[1,2,1,0],
         *     [2,1,-1,1],
         *     [0,1,2,-1]]
         * </pre>
         * <p>
         * 首先遍历出所有连续行的组合状况 [i, j] 其中 i <= j
         * <p>
         * 上述例子就是 [0,0],[0,1],[0,2],[1,1],[1,2],[2,2]这6种状况
         * <p>
         * 设矩阵有 M 行 N 列
         * <p>
         * 用一个长度为 N 的数组 sum[N] 存储 [i,j] 连续行内的每一列的和
         * <p>
         * 如：[0,2] 的sum = [3,4,1,0]
         * <p>
         * 此问题就转化为了求 sum 的连续子序列和的最大值
         * <p>
         * 此时还要维护的子矩阵的左上角和右下角的坐标
         * <p>
         * 时间复杂度:O(M*N^2);空间复杂度:O(N)
         */
        public int[] getMaxMatrix(int[][] matrix) {
            //维护子矩阵的最大值
            int max = Integer.MIN_VALUE;
            int dp = 0, start = 0;
            int[] ans = new int[]{-1, -1, 200, 200};//结果
            int[] sum = null;//纵向累加数组[i,j]
            for (int i = 0; i < matrix.length; i++) {
                sum = new int[matrix[0].length];
                for (int j = i; j < matrix.length; j++) {
                    // dp表示以k结尾的sum数组连续子序列和的最大值,新起一列当然要重新来算
                    // 也可以这么理解,子矩阵和就是一维数组sum[k]的和,一行即可
                    dp = 0;
                    // 重新开始一行就要刷新起始列位置为0,因为dp也在此时进行刷新
                    // 换句话说就是接下来计算得到的dp>max时,默认都是从第0列开始计算的
                    start = 0;
                    // k表示遍历matrix[j]的每一个元素matrix[j][k]的索引,范围:[0,N-1]
                    for (int k = 0; k < sum.length; k++) {
                        // 计算新一行的sum[k]
                        sum[k] += matrix[j][k];
                        // 先计算dp[k],假设要了sum[k]
                        dp += sum[k];
                        // 若dp>max表明当前的子矩阵[i,start,j,k]为对角坐标的子矩阵和>之前的最大值
                        // 说明找到新的最大子矩阵的和,可以更新res了
                        // 归根到底就是在遍历所有以sum[k]结尾的情形找到最大值并保存其最大值坐标到res里
                        // 参考"最大连续子数组的和"的状态压缩写法就懂了
                        if (max < dp) {
                            ans[0] = i;
                            ans[1] = start;
                            ans[2] = j;
                            ans[3] = k;
                            // 更新最大子矩阵和
                            max = dp;
                        }
                        // 若碰到dp<0表明当前sum[start,k]的和将会对后面的起拖累作用
                        // 因此以k+1为结尾sum[k+1]的不能前面段合并
                        if (dp < 0) {
                            // 后面sum[k+1]结尾的，连续子序列和要另起炉灶
                            dp = 0;
                            // 更新列的起始坐标(不被前面的拖累因此为k+1)
                            start = k + 1;
                        }
                    }
                }
            }
            return ans;
        }
    }

}
