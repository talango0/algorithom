package leetcode.dp;

import leetcode.string._5_最长回文串;
//给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。
//
//请你返回让 s 成为回文串的 最少操作次数 。
//
//「回文串」是正读和反读都相同的字符串。
//
//示例 1：
//
//输入：s = "zzazz"
//输出：0
//解释：字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。
//示例 2：
//
//输入：s = "mbadm"
//输出：2
//解释：字符串可变为 "mbdadbm" 或者 "mdbabdm" 。
//示例 3：
//
//输入：s = "leetcode"
//输出：5
//解释：插入 5 个字符后字符串变为 "leetcodocteel" 。
//提示：
//
//1 <= s.length <= 500
//s 中所有字符都是小写字母。
//Related Topics
//
//👍 153, 👎 0

/**
 * 字节
 * @author mayanwei
 * @date 2022-08-18.
 * @see _516_最长回文子序列
 * @see _5_最长回文串
 */
public class _1312_让字符串成为回文串的最少插入次数{
    class Solution{
        /**
         * 定义 dp 数组
         * dp[i][j] 表示对于字符串 s[i..j] 最少需要进行 dp[i][j] 次插入才可以变为回文字符串
         * 最终的的答案为 dp[0][n-1]
         * 对于 dp[i][j]， dp[i+1][j-1]就是它的子问题
         */
        public int minInsertions(String s) {
            int n = s.length();

            int[][] dp = new int[n][n];
            // 当 i == j 时，相当于一个字符，本身回文，所以 dp[i][i] = 0
            for (int i = 0; i < n; i++) {
                dp[i][i] = 0;
            }
            // 状态转移方程
            // 对于dp[i][j]，dp[i+1][j-1]就是他的子问题，假设已经计算出dp[i+1][j-1]，相当于s[i:j+1]已经是一个回文子串了
            // 当s[i]==s[j]时，s[i:j+1]本身就是一个回文了,不需要任何插入，所以dp[i][j]=dp[i+1][j-1]
            // 如果s[i]！=s[j]，分情况讨论：
            // a b --> a b b a
            // 如果先把s[j]插到s[i]右边，同时把s[i]插到s[j]右边，这样得到的肯定是一个回文，但不一定是最优的
            // 比如有一边是回文，如 abbbb，这个时候只需要在右边添加一个a即可，
            // abbbb --> a b b b b a
            // 所以第一步，做选择，先将s[i:j] 或s[i+1:j+1]变为回文，只需判断哪个变为回文所需的操作少就变哪个
            // 即判断dp[i][j-1] 和dp[i+1][j]的大小，哪个小就选哪个
            // 所以，根据第一步的选择，将s[i:j+1]变为回文。
            // 如果第一步中选择把s[i+1:j+1]变为回文，那么只需在s[i+1:j+1]的右边插入s[i]即可将s[i:j+1]变为回文
            // 或者第一步中选择将s[i:j]变为回文，只需在s[i:j]的左边插入s[j]即可
            // 所以状态转移方程为
            // if s[i]==s[j]:
            //     dp[i][j] = dp[i+1][j-1]
            // else:
            //     dp[i][j] = min(dp[i][j-1], dp[i+1][j]) + 1
            // 前面知道，dp[i][i]=0，而dp[i][j]与dp[i][j-1]， dp[i+1][j]和dp[i+1][j-1]有关
            // 为了保证每次计算dp[i][j]时，这三个状态都已经被计算，我们一般选择从下向上，从左到右遍历dp数组：

            // 从下往上遍历，要先得到 i+1，再有i
            for (int i = n - 1; i >= 0; i--) {
                // 从左往右遍历，要先得到j-1，再有j
                for (int j = i + 1; j < n; j++) {
                    if (s.charAt(i) == s.charAt(j)) {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                    else {
                        dp[i][j] = Math.min(dp[i][j - 1], dp[i + 1][j]) + 1;
                    }
                }
            }
            return dp[0][n - 1];

        }
    }
}
