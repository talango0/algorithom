package leetcode.math;

//给你一个整数 n ，请你找出并返回第 n 个 丑数 。
//
//丑数 就是只包含质因数 2、3 和/或 5 的正整数。
//
//示例 1：
//
//输入：n = 10
//输出：12
//解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
//示例 2：
//
//输入：n = 1
//输出：1
//解释：1 通常被视为丑数。
//提示：
//
//1 <= n <= 1690
//Related Topics
//
//👍 950, 👎 0
//通知：数据结构精品课 V1.8 持续更新中；第十期刷题打卡挑战 开始报名。

/**
 * @author mayanwei
 * @date 2022-08-16.
 */
public class _264_丑数II{
    class Solution {
        // 如果 x 时丑数，那么 x * 2, x * 3, x * 5
        // 1 -> 2 -> 3 -> 5 -> 6 -> 8
        //  能被 2 整除的丑数：
        // 1*2 -> 2*2 -> 3*2 -> 4*2 -> 5*2 -> 6*2 -> 8*2 ->...
        // 能被 3 整除的丑数：
        // 1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 8*3 ->...
        // 能被 5 整除的丑数：
        // 1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 8*5 ->...
        // 我们如果把这三条「有序链表」合并在一起并去重，得到的就是丑数的序列，其中第n个元素就是题目想要的答案：
        // 1 -> 1*2 -> 1*3 -> 2*2 -> 1*5 -> 3*2 -> 4*2 ->...
        public int nthUglyNumber(int n) {
            // 可以理解为三个指向有序链表头结点的指针
            int p2 = 1, p3 = 1, p5 = 1;
            // 可以理解为三个有序链表的头节点的值
            int product2 = 1, product3 = 1, product5 = 1;
            // 可以理解为最终合并的有序链表（结果链表）
            int [] ugly = new int[n + 1];
            // 可以理解为结果链表上的指针
            int p = 1;
            // 合并三个有序链表，找到第n个丑数时结束
            while (p <= n) {
                // 去三个链表的最小节点
                int min = Math.min(Math.min(product2, product3), product5);
                ugly[p] = min;
                p++;
                // 前进对应的有序链表到结果链表上
                if (min == product2) {
                    product2 = 2 * ugly[p2];
                    p2++;
                }
                if (min == product3) {
                    product3 = 3 * ugly[p3];
                    p3++;
                }
                if (min == product5) {
                    product5 = 5 * ugly[p5];
                    p5++;
                }
            }
            return ugly[n];
        }
    }
}
