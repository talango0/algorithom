package leetcode.math;
//集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有
//一个数字重复 。
//
// 给定一个数组 nums 代表了集合 S 发生错误后的结果。
//
// 请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
//
//
//
// 示例 1：
//
//
//输入：nums = [1,2,2,4]
//输出：[2,3]
//
//
// 示例 2：
//
//
//输入：nums = [1,1]
//输出：[1,2]
//
//
//
//
// 提示：
//
//
// 2 <= nums.length <= 10⁴
// 1 <= nums[i] <= 10⁴
//
//
// Related Topics 位运算 数组 哈希表 排序 👍 277 👎 0

import leetcode.bitop._268_丢失的数字;

/**
 * @see _268_丢失的数字
 * @author mayanwei
 * @date 2022-08-06.
 */
public class _645_错误的集合{
    // 总结：对于这种数组问题，关键点在于元素和索引是成对儿出现的，常用的方式是排序、异或、映射
    //映射的思路就是我们刚才的分析，将每个索引和元素映射起来，通过正负号记录某个元素是否被映射。
    //
    //排序的方法也很好理解，对于这个问题，可以想象如果元素都被从小到大排序，如果发现索引对应的元素如果不相符，就可以找到重复和缺失的元素。
    //
    //异或运算也是常用的，因为异或性质 a ^ a = 0, a ^ 0 = a，如果将索引和元素同时异或，就可以消除成对儿的索引和元素，留下的就是重复或者缺失的元素。

    class Solution {
        // 通过将每个索引对应元素变成负数，以表示这个索引被对应过一次了
        public int[] findErrorNums(int[] nums) {
            int n = nums.length;
            int dup = -1;
            for (int i = 0; i < n; i++) {
                // 现在的元素是从1开始的
                int index = Math.abs(nums[i]) - 1;
                if (nums[index] < 0 ) {
                    dup = Math.abs(nums[i]);
                }
                else {
                    nums[index] *= -1;
                }
            }
            int missing = -1;
            for (int i = 0; i < n; i++) {
                if (nums[i] > 0) {
                    // 将索引转换成元素
                    missing = i + 1;
                }
            }
            return new int[]{dup, missing};
        }
    }
}
