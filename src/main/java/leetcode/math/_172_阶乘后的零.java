package leetcode.math;
//给定一个整数 n ，返回 n! 结果中尾随零的数量。
//
// 提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1
//
//
//
// 示例 1：
//
//
//输入：n = 3
//输出：0
//解释：3! = 6 ，不含尾随 0
//
//
// 示例 2：
//
//
//输入：n = 5
//输出：1
//解释：5! = 120 ，有一个尾随 0
//
//
// 示例 3：
//
//
//输入：n = 0
//输出：0
//
//
//
//
// 提示：
//
//
// 0 <= n <= 10⁴
//
//
//
//
// 进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？
//
// Related Topics 数学 👍 693 👎 0
/**
 * @see _793_阶乘函数后K个零
 * @author mayanwei
 * @date 2022-08-05.
 */
public class _172_阶乘后的零{
    class Solution {
        // 首先，两个数相乘末尾有0，一定是因为两个数中有因子 2 和 5 ，10 = 2*5
        // 也就是说 n！ 最多可以分解出多少个因子 2 和 5
        // 再进一步，主要取决于 多少个因子 5，因为每个偶数都能分解出因子2，因子2 肯定比因子5多的多。
        // 25！中5、10、15、20个提供一个5 ，25可以提供两个 5，总共 6 个因子 5，所以 25！的结果末尾有 6 个0
        // 现在：问题转化为： n! 最多可以分解出多少个因子5
        // 假设 n = 125，来计算 125！
        // 125/5 = 25 这一步就是计算有多少个像 5，15，20，25 这些5的倍数，他们一定可以提供一个因子5
        // 像 25， 50，75 这些25 的倍数可以提供两个因子5。125/25 = 5个25的倍数，他们每人可以额外再提供1个因子 5
        // 125 = 5 * 5 * 5 像 125， 250这些125的倍数，可以提供3个因子5，那么我们还得再计算 125！中有 125/125 = 1个125的倍数，它还可以额外再提供一个因子5
        // 25 + 5 + 1 = 31个因子5，也就是说结成末尾有31个0.

        //  O(logN)
        public int trailingZeroes(int n) {
            int res = 0;
            // long divisor = 5;
            // while (divisor <= n) {
            //     res += (n/divisor);
            //     divisor *= 5;
            // }
            for (int d = n; d / 5 > 0; d = d / 5) {
                res += d / 5;
            }
            return res;
        }
    }
}
