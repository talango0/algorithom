package charactor;

import org.junit.Assert;
import org.junit.jupiter.api.Test;

/**
 * @author mayanwei
 * @date 2022-12-02.
 */
public class Test1{
    @Test
    public void testAscii(){
        /**
         * ASCII 字符集支持 128 种字符，仅使用 7 个 bit 位，也就是一个字节的后 7 位就可以将它们全部表示出来，
         * 而最前面的一位统一规定为 0 即可（如 0110 0001 表示 a）
         * 后来，为了能够表示更多的欧洲国家的常用字符如法语中带符号的字符 é，又制定了 ASCII 额外扩展的版本 EASCII，
         * 这里就可以使用一个完整子节的 8 个 bit 位表示共 256 个字符，其中就又包括了一些衍生的拉丁字母。
         */
        Assert.assertEquals((char) 97, 'a');
        System.out.println((char) 228);
        System.out.println( (int)'é');

    }

    @Test
    public void testGB2312_GBK(){
        //ASCII 字符集沿用至今，但它最大的缺点在于只能表示基本的拉丁字母、阿拉伯数字和英式标点符号，因此只能表示现代美国英语（而且在处理英语当中的外来词如 naïve、café、élite 等等单词时，所有重音符号都不得不去掉）。而 EASCII 虽然解决了部份西欧语言的显示问题，但是当计算机传入亚洲之后，各国的语言依然不能完整地表示出来。
        //在这个年代，每个国家就各自来对 ASCII 字符集做了拓展，最具代表性的就是国内的 GB 类的汉字编码模式，这种模式规定：ASCII 值小于 127 的字符的意义与原来 ASCII 集中的字符相同，但当两个 ASCII 值大于 127 的字符连在一起时，就表示一个简体中文的汉字，前面的一个字节（高字节）从 0xA1 拓展到 0xF7，后面一个字节（低字节）从 0xA1 到 0xFE，这样就可以组合出了大约 7000 多个简体汉字了。
        //为了在解码时操作的统一，GB 类编码表中还也加入了数学符号、罗马希腊的字母、日文的假名等，连在 ASCII 里本来就有的数字、标点、字母都统一重新表示为了两个字节长的编码，这就是我们常说的 "全角" 字符，而原来在 127 号以下的那些就叫 "半角" 字符了，这种编码规则就是后来的 GB2312。
        //
        //"一个汉字算两个英文字符！一个汉字算两个英文字符……"
        System.out.println(Integer.toHexString((int)'一'));

    }

    /**
     *
     * Unicode
     * 正如上一节中所说的，世界上各国都有不同的编码方式，同一个二进制数字可以被解码成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为了解决这个问题，最终的集大成者 Unicode 字符集出现了，它将世界上所有的符号都纳入其中，成功实现了每个数字代表唯一的至少在某种语言中使用的符号，目前，Unicode 字符集中已经收录超过 13 万个字符（第十万个字符在2005年获采纳）。值得关注的是，Unicode 依然兼容 ASCII，即 0～127 意义依然不变。
     */
}
