# 重提二叉树的重要性
* 快速排序本质上是一个二叉树前序遍历
* 归并排序本质上是一个二叉树后续遍历

#二叉树的刷题思路
前序、中序、后续遍历是处理每一个节点的三个时间点，如下图。
![img.png](再刷二叉树算法/img.png)

二叉树的所有问题，就是让在前中后序位置注入代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该干什么，二叉树的遍历会递归在每一个节点上做相同的操作。
主要思路有两类：

1. 是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。
2. 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：
如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

366.二叉树的叶子节点
![img.png](再刷二叉树算法/img1.png)


# 二叉树（构造篇）

二叉树的构造问题一般都是使用 **分解问题** 的思路： **构造整棵树 = 根节点 + 构造左子树 + 构造右子树**

例如：654


# 二叉树序列化
前序遍历、后序遍历、层序遍历都可, 但中序不遍历不行，因为
中序遍历无法 deserialize

例如 
* [297](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

# 二叉搜索树
1. 如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。
2. 在二叉树递归框架之上，扩展出一套 BST 代码框架：

```
void BST(TreeNode root, int target) {
    if (root.val == target)
    // 找到目标，做点什么
    if (root.val < target)
    BST(root.right, target);
    if (root.val > target)
    BST(root.left, target);
}
```
3. 根据代码框架掌握了 BST 的增删查改操作。