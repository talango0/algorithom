# 问题1 剪绳子

## 1.问题描述

一根长为n的钢条，将其切成段钢条出售，切割工序本身没有成本，给出最佳的切割方案。假定出售一段长度为i英寸的钢条的价格为$p_i$ $i = 1,2,...$ 钢条长度均为整数。

价格表如下:

| 长度$i$   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 价格$p_i$ | 1    | 5    | 8    | 9    | 10   | 17   | 17   | 20   | 24   | 30   |

## 2.解决方案

### 使用动态规划方法求解最优钢条切割问题.

> 动态规划方法思想:
>
> 朴素的递归调用算法之所以低效，是因为它反复求解相同的子问题。因此，动态规划方法仔细安排求解顺序，对每个子问题只求解一次，并将结果保存下来。如果再次需要计算此子问题的解，只需超着保存的结果。而不必重新计算。
>
> 因此，动态规划方法是付出额外的保存空间来节省计算时间，是典型的时空权衡（time-memory trade-off）的例子。而时间上的节省可能是非常巨大的：可能将一个指数时间的解转化为一个多项式时间的解。
>
> 如果子问题的数量是输入规模的多项式函数，而我们可以在多项式时间内求解出每个子问题，那么动态规划方法总运行时间就是多项式的。

### 动态规划有两种等价实现方式

* 带备忘的自顶向下法（top-town with memoization）

  ```
  MEMOIZED_CUT_ROD(p, n)
  	let r[0...n] be a new array
  	for i = 0 to n
  		r[i] = $-\infty$
  	return MEMOIZED_CUT_ROD_AUX(p, n, r)
  MEMOIZED_CUT_ROD_AUX(p, n, r)
  	if r[n] >= 0
  		return r[n]
  	if n = 0
  		q = 0
  	else q = $-\infty$
  		for i = 1 to n:
  			q = max(q, p[i] + MEMOIZED_CUT_ROD_AUX(p, n-i, r))
  	r[n] = q
  	return q
  ```

    * 主过程MEMOIZED_CUT_ROD首相初始化r[0...n]为$-\infty$ ，这是一种常见的初始化方式，（已知收益均为非负值），然后调用辅助过程MEMOIZED_CUT_ROD_AUX
    * 过程MEMOIZED_CUT_ROD_AUX是最初的CUT_ROD引入了备忘机制，如果r[0...n]中已经计算出了该子问题，则直接返回；否则用通用的方法计算出q，并将q存入r中

* 自底向上法（botom-up method）

  ```
  BOTTOM_UP_CUT_ROT(p, n)
  	let r[0...n] to be new Array
  	r[0] = 0
  	for j = 1 to n
  		q = $-\infty$
  		for i = 1 to j
  			q = max(q, p[i] + r[j-1])
  		r[j] = q
  	return r[n]
  
  ```


* 自底向上版本BOTTOM_UP_CUT_ROT采用子问题的自然顺序：若i< j,则规模为i的子问题比规模为j的规模更小。因此，过程一次求解规模为 j = 0,1,...,n

* #### 算法时间复杂度分析

  两种方法的复杂度都是 $\Theta( n^{2})$

## 3.子问题图

当思考一个动态规划问题时应该弄清楚所设计的子问题和子问题的之间的依赖关系。

![image-20200728141937258](动态规划/image-20200728141937258.png)

图中表示 n = 4时，钢条切割子问题图。顶点表示子问题的规模，有向边$(x,y)$ 表示求解子规模问题 $x$ 时需要子问题 $y$ 的解。

## 4. 重构解

前面钢条切割问题返回最优解的收益值，但并未返回切割方案（一个长度为n的列表，给出每段切割的长度）。采用扩展的动态规划算法，使之对每个子问题不仅保存最优收益值，还保存对应的切割方案。

下面给出BOTTOM-UP-CUT-ROD的扩展版本，它对长度为j的钢条不仅计算最大收益$r_j$ 还保存最优解对应的每一段钢条的切割长度$s_j$

```
EXTEND-BOTTOM-UP-CUT-ROD(p, n)
	let r[0...n] and s[0...n] be new arrays
	r[0] = 0
	
	for j = 1 to n
		q = $-\infty$
		for i = 1 to j
			if q < p[i] + r[j-i]
				q = p[i] + r[j-i]
				s[j] = i
			r[j] = q
	return r and s
```

此过程和BOTTOM_UP_CUT_ROT差异很小，差别只是在开创建了一个数组s[0...n]，并在求解规模为j的子问题中在s中保存了切割方案。

下面过程接受两个参数价格表p和钢条长度n，然后调用EXTEND-BOTTOM-UP-CUT-ROD来计算切割下来的每段钢条的长度s[1...n]，最后输入长度为n的钢条的完整的最优切割方案：

```
PRINT-CUT-ROD-SOLUTION(p, n)
	(r, s) = EXTEND-BOTTOM-UP-CUT-ROD(p, n)
	while n>0:
		print(s[n])
		n = n-s[n]
```

# 问题2 矩阵链乘法

## 1.问题描述

矩阵链相乘问题。给出一个$n$ 个矩阵的$<A_1,A_2,...,A_n >$ 计算他们的乘积 $A_1A_2...A_n$ 。

为了计算 $A_1A_2...A_n$，我们可以先用括号明确计算次序，然后利用标准的矩阵相乘的方法进行计算。由于矩阵乘法满足结合律，因此任何加括号的方法都会得到相同的结果。

我们称有如下性质的矩阵乘积链为**完全括号化**（fully parenthesized）：它是一个单一矩阵，或者是有两个完全括号化的矩阵乘积链的积，且已经外加括号。

例如如果矩阵链为$<A_1,A_2,A_3,A_4 >$，则它共有5种完全括号化的矩阵乘积链，分别如下： $$
(A_1(A_2(A_3A_4)))\\(A_1((A_2A_3)A_4))\\((A_1A_2)(A_3A_4))\\((A_1(A_2A_3)A_4))\\(((A_1A_2)A_3)A_4))
$$ 矩阵链乘法问题（matrix-chain multiplication problem）可描述如下：

给定$n$ 个矩阵的链 $<A_1,A_2,...,A_n >$ ，矩阵 $A_i$ 的规模为 $p_{i-1}*p_i(1\leqslant i \leqslant n)$ ，求完全括号化方案，使得计算乘积 $A_1A_2...A_n$
所需标量计算的乘法次数最少。

## 2.计算括号化方案的数量

$$ P(n)=\begin{cases} 1 &,&n=1 \\ {\sum\limits_{k=1}^{n-1}{ P(k)P(n-k))}} &,&n\geqslant 2 \end{cases} $$

括号化方案的数量与 $n$ 呈指数关系 $\Omega(2^n)$ 。

## 3.动态规划求解矩阵链乘法的最优括号化方案

* 刻画一个最优的结构特征；
* 递归地定义最优解的值；
* 计算最优解的值，通常采用自底向上的方法；
* 利用计算出的信息构造一个最优解。

我们依旧按照上述四个步骤求解。

### **步骤1、刻画一个最优的结构**

我们用符号 $A_{i,j}（i \leqslant j）$ 表示 $A_iA_{i+1}...A_j$ 乘积的结果矩阵。如果问题是非平凡的，即 $i<j$ ，为了对 $A_iA_{i+1}...A_j$ 进行括号化，我们必须在某个
$A_k$ 和 $A_{k+1}$ 之间划分开，其中 $k$ 为 $i \leqslant k <j $ 之间的整数。也就是说，对某个整数 $k$ ,首先计算 $A_{i,k}$ 和 $A_{k+1,j}$ ，然后再计算它们的乘积得到
$A_{i,k}$ 。此方案的复杂度为矩阵 $A_{i,k}$ 的计算代价 + $A_{k+1,j}$ 的计算代价 + $A_{i,k}$ 与 $A_{k+1,j}$ 的乘积的计算代价。

下面给出最优子结构。

假设的最优括号化方案分割点在 $A_k$ 和 $A_{k+1}$ 之间，那么

* 对于前缀子链 $A_i...A_k$ 进行括号化时，我们应该直接采用独立求解它们时所得的最优方案。

  这样做是什么原因？

  如果不采用独立求解 $A_i...A_k$ 所得的最优化方案来进行括号化，可以将此最优解代入 $A_iA_{i+1}...A_j$ 的最优解中，代替原来对子链进行括号化的方案（ 比$A_i...A_k$
  最优解的代价更高），这样得到的解比原来最优解代价更低；产生矛盾。

* 对于后缀子链 $A_{k+1}...A_j$ 也是同样的道理。

### **步骤2、递归地求解最优的值**

下面用子问题的最优解来递归地定义原问题最优解的代价。

对矩阵链乘法问题，我们可以将对所有 $1 \leqslant i \leqslant j \leqslant n$ 确定 $A_iA_{i+1}...A_j$ 的最小代价括号化方案作为子问题。令 $m[i,j]$ 表示矩阵 $A_
{i,j}$ 所需标量乘法最小值，那么，原问题的最优解——计算 $A_{1...n}$ 的最低代价就是 $m[1,n]$ 。

递归定义 $m[i,j]$ ，对于 $i==j$ 的平凡问题，矩阵链只包含唯一的矩阵 $A_{i,i} = A_i$ 。因此不需要进行标量乘法，所以对于 $i= 1,2,...,n,\;m[i,i]=0$ 。若 $i<j$
,我们采用步骤1得到的最优子结构计算 $m[i,j]$ , 我们假设 ${A_iA_{i+1}...A_j}$ 的最优化括号方案的分割点在矩阵 $A_{k}$和$A_{k+1}$ 之间 ，其中$i\leqslant k < $ j，那么，
$m[i,j]$ 就等于计算 $A_{i...k}$ 和 $A_{k+1...j}$ 代价加上二者相乘的结果，因为矩阵 $A_{i}$ 的大小为 $p_{i-1}\times p_{i} $，易知，$A_{i...k}$ 与 $A_
{k+1...j}$ 的代价为 $p_{i-1}p_{k}p_{j}$ 次标量的乘法。因此得到如下的递归求解公式。 $$ m[i,j]=\left\{\begin{matrix} 0 &,&i=j \\ \min\limits_
{1\leqslant k < n }\{ \;m[\,i...k\,] + m[\,i+1...j\,] + p_{i-1}p_{k}p_{j}\;\} &,&i<j \end{matrix}\right. $$ $m[i,j]$
给出了问题的子问题的最优解代价，但并未提供足够的信息来构造最优解。为此，采用 $s[i,\, j]$ 保存 $A_iA_{i+1}...A_{j}$ 的最优括号化方案的分隔位置 $k$ 。即使得 $m[i,j] = m[i,k] +
m[k+1,j] + p_{i-1}p_kp_j$ 成立的$k$。

### **步骤3、计算最优解代价**

```
MATRIT_CHAIN_ORDER(p):
	let m[1..n, 1...n], s[1...n-1,2...n] be new Array
  for i=0 to n
  	m[i,i] = 0
  for l=2 to n
  	for i = 1 to n-l+1
  		j = i+l-1
  		A[i,j] = ∞
  		for k = i to j
  			q = m[i,k] + m[k+1,j] + $p_{i-1} p_{k} p_{j}$
  			if q< m[i,j]
  				m[i,j] = q
  				s[i,j] = s
  return m, s

```

### **步骤4、构造最优解**

```
PRINT_OPTION_PARENS(s, i, j)
	if i = j
		PRINT "A"i
	else
		PRINT "("
		PRINT PRINT_OPTION_PARENS(s, i, s[i,j])
		PRINT PRINT_OPTION_PARENS(s, s[i,j]+1, j)
		PRINT ")"
```

# 动态规划原理

## 1. 什么情况下适合动态规划

使用动态规划求解最优解问题应该具备两个特征

* 最优子结构
* 子问题重叠

## 2. 最优子结构

**通用模式**

* 证明问题最优解的第一个组成部分是做出一个选择，例如，选择钢条切割第一切割的位置，选择矩阵链的划分位置。做出这个选择会产生一个或多个待解的子问题。
* 对于一个给定的问题，其可能的第一步选择中，你假定已经知道了哪种选择才会得到最优解，你现在并不关心这种选择具体是如何得到的，只是知道了这种选择。
* 给定可获得最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地刻画子问题的空间。
* 利用“剪贴-粘贴”（cut-and-paste）的技术证明：作为构成原问题最优解的组成部分，每个子问题的解就是他本身的最优解。（可以采用反证法证明。）

## 3. 重叠子问题

## 4. 重构最优解

## 5. 备忘

# 问题3 最长公共子序列

一个给定序列的**子序列（subsequence）**，就是将给定的序列中零个或者多个元素去掉后得到的结果。其形式化定义如下：

给定序列 $X = <x_1,x_2,...,x_n>$ ，另一个序列 $X = <z_1, z_2, ... , z_k>$ 满足如下条件时称为 $Z$ 的子序列（subsequence)    ，即存在一个严格递增的下标序列 $<
i_1, i_2, ...,i_k> $ 对所有的 $j =1, 2, ..., k$ 满足 $x_{i_{j}} = z_j$ 。

**最长公共子序列问题（longest-common-subsequence problem，LCS）** 给定两个序列 $X = <x_1,x_2,...,x_m>$ 和 $Y=<y_1,y_2,...,y_n>$ , 求 $X$ 和
$Y$ 的最长公共子序列。

例如：$X= <A,B,C,B,D,A,B>$, $Y = <B,D,C,A,B,A>$ ，$<B,C,B,A>$ 是一个最长公共序列，其长度为4，$<B,D,A,B>$ 也是X，Y的最长公共序列。但是 $<B,D,A>$
不是因为它的长度为3。

**下面采用动态规划高效地求解LCS问题**

暴力法求子串复杂度为指数阶。

## **步骤1**： 寻找一个最优子结构

* **前缀**

  给定一个序列$X = <x_1,x_2,...,x_m>$ ，对 $i=0,1,...,m$ ，定义X的第 $i$ 个前缀是 $X_i= <x_1, x_2, ...,x_i>$ ，例如$X= <A,B,C,B,D,A,B>$,
  $X_4= <A,B,C,B>$ , $X_0 = 0$。

* **定理3.1（LCS的最优子结构）**

  **给定两个序列 $X = <x_1,x_2,...,x_m>$ 和 $Y=<y_1,y_2,...,y_n>$ ，$Z=<z_1,z_2,...,z_k>$ 为$X$ 和$Y$ 的任意LCS,**

    * **如果 $x_m= y_n$ ，则 $x_m = y_n = z_k$ ,且 $Z_{k-1}$ 是 $X_{m-1} $ 和 $X_{n-1}$ 的一个LCS；**
    * **如果 $x_m \neq y_n$ ，那么 $x_m \neq z_k$ 意味着 $Z$ 是 $X_{m-1}$ 和 $Y$ 的一个LCS；**
    * **如果 $x_m \neq y_n$ ，那么 $y_m \neq z_k$ 意味着 $Z$ 是 $X$ 和 $Y_{n-1}$ 的一个LCS。**

* 定理3.1 可知，两个序列的LCS包含两个序列前缀的LCS。因此具有LCS问题具有最优子结构的性质。下面我们也可以看到具有重叠子问题的性质。

## **步骤2**：递归定义最优解

定义$c[i,j]$ 表示 $X_{i}$ 和 $Y_{j}$ 的LCS的长度。 $$ c[i,j]=\begin{cases} 0 &,& i=0 \,或\, j=0 \\ c[i-1,j-1]+1 &,& i,j>0,且x_{i} =
y_{j} & (3.1)\\ \max(c[i-1,j],c[i,j-1]) &,& i,j>0，且x_{i} \neq y_{j} \end{cases} $$

## **步骤3:**  计算LCS的长度

从式3.1可可以容易写出一个复杂度为指数级的地方方法。

由于共有 $\Theta (m*n)$ 个子问题，我们采用动态规划自底向上的的算法求解。

LCS_LENGTH(X, Y)接受两个参数 $X = <x_1,x_2,...,x_m>$ 和 $Y=<y_1,y_2,...,y_n>$ ，它将 $c[i,j]$ 的值保存在 $c[0...m,0...n]$
中，并按主次序（row-major-order） 计算表项，（即首先计算从左到右计算第一行，再算第二行，依此类推），过程中维护了 $b[1...m,1...n]$ 保存了表项对应计算 $c[i,j]$
时所选择的最优解。过程返回表b，表c，$c[m,n]$ 保存了LCS的长度。

```
LCS_LENGTH(X, Y)
	m = X.length, n = Y.length
	let b[1...m,1...n] and c[0...m,0...n] be new Array
	for i = 1 to m
		c[i,0] = 0
	for j = 1 to n
		c[0,j] = 0
	for i = 1 to m
		for j = 1 to n
			if x_i == y_j
				c[i,j] = c[i-1][j-1] + 1
				b[i,j] = ↖
			elif c[i-1,j] >= c[i,j-1]
				c[i,j] = c[i-1,j]
				b[i,j] = ⬆
			else 
				c[i,j] = c[i,j-1]
				b[i,j] = ⬅
		return c, b
```

## 步骤4: 构造LCS

```
PRINT_LCS(b, X, i, j)
	if i== 0 or j == 0
		return
	if b[i,j] == ↖
		PRINT_LCS(b, X, i-1, j-1)
		print x[i]
	elseif b[i,j] == ⬆
		PRINT_LCS(b, X, i-1, j)
	else 
		PRINT_LCS(b, X, i, j-1)
```

* 算法时间复杂度 $O（m+n）$

## 算法改进

可以完全去掉 表b，因为c[i,j] 只依赖于表c中的其他三项，c[i-1,j-1] , c[i-1,j], c[i,j-1] 。给定 c[i,j] 的值，我们可以在 O(1) 的时间内判断出计算c[i,j] 时用了哪3项。

# 问题4 最优二叉搜索树

最优二叉搜索树（Optimal binary search tree）问题，形式化定义：给定一个n个不同关键字的已排序的序列 $K= <k_1,k_2,\cdots,k_n>,(k_1<k_2<\cdots <k_n)$
,我们希望用这些关键字构建一棵树。对于每个关键字 $k_i$ ，都有一个概率 $p_i$ 表示搜索频率。有些要搜索的值可能不在 $K$ 中，因此我们还有$n+1$ 个“伪关键字” $d_0,d_1,\cdots,d_{n}$ 表示不在
$K$中的值。其中，$d_0$ 表示所有小于 $k_1$ 的值，$d_n$ 表示所有大于 $k_n$ 的值，$d_i\;(1\leqslant i \leqslant n-1)$ 表示所有在 $k_i$,和$k_{i+1}$
之间的值。对于每个“伪关键字”都有一个概率$q_i$ 表示对应的搜索频率。每个关键字$k_i$时一个内部结点，而每个伪关键字$d_i$
是一个叶结点。每次搜索关键字要么成功（找到了某个关键字$k_i$），要么失败（找到某个伪关键字$d_i$），因此:
$$ \sum_{i=1}^{n} p_i + \sum_{i=0}^{n}q_i = 1 \tag{4.1} $$ 例如，下表显示对于一个n=5个关键字的集合构成的二叉搜索树

对于一个n=5的关键字集合集如下的搜索该概率构造的两棵二叉搜索树。

![image-20200814133951443](动态规划/image-20200814133951443.png)

| i | 0 | 1 | 2 | 3 | 4 | 5 | | :----: | :--: | :--: | :--: | :--: | :--: | :--: | | $p_i $ | | 0.15 | 0.10 | 0.05 |
0.10 | 0.20 | | $q_i$ | 0.05 | 0.10 | 0.05 | 0.05 | 0.05 | 0.10 |

我们知道每个关键字和伪关键字的搜索概率，因而可以确定在一棵给定的二叉搜索树T中进行一次搜索的期望代价。假定一次搜索的代价等于访问的结点个数，即此搜索树找到结点在T中的深度加1。那么在T中进行一次搜索的期望代价为： $$
\begin{align} E\left [ T中搜索代价 \right ]  &= \sum\limits_{i=1}^{n}{(depth_{T}(k_{i})+1) \cdot p_i } + \sum\limits_
{i=0}^{n}{(depth_{T}(d_{i})+1) \cdot q_i } \\&=1 + \sum\limits_{i=1}^{n}{depth_{T}(k_{i}) \cdot p_i } + \sum\limits_
{i=0}^{n}{depth_{T}(d_{i}) \cdot q_i } \end{align} \tag{4.2} $$ 对于一个给定的概率集合，我们希望构造一棵期望搜索代价最小的二叉搜索树，我们称之为最优二叉搜索树。

## 步骤1 最优二叉树的结构

特征：考虑二叉搜索树的任意子树。它必须包含连续关键字 $k_i, \cdots, k_j\;,1\leqslant i \leqslant j \leqslant n $ ,而且其叶结点必然是伪关键字 $d_{i-1},\cdots,d_
{j}$ 。

二叉搜索树的最优子结构：如果一棵最优二叉搜索树 $T$ 有一棵包含关键字 $k_i, \cdots, k_j $ 的子树 ${T}'$ ,那么 ${T}'$ 必然包含关键字 $k_i, \cdots, k_j $ 和伪关键字 $d_
{i-1},\cdots,d_{j}$ 的子问题的最优解。

> * 可以采用反正法证明
>
> 如果存在 $T{''} $ ，其期望搜索代价比 $T{'}$ 低，那么我们将 $T{'}$ 从 $T$ 中删除，然后把 $T{''} $ 粘贴到相应的位置，从而得到一颗期望搜索代价低于 $T$ 的最优二叉搜索树，这与假设相矛盾。

> * 利用最优子结构性质证明，我们可以利用子问题的最优解构造原问题的最优解。
>
> 给定关键字序列 $k_i, \cdots, k_j $ ，其中某个关键字，比如 $k_r(i \leqslant r \leqslant j)$ 是这些关键字的根结点。那么 $k_r$ 的左子树就包含关键字 $k_i, \cdots, k_{r-1} $ （和伪关键字 $d_{i-1},\cdots,d_{r-1}$）及包含关键字 $k_{r+1}, \cdots, k_j $ (和伪关键字 $d_{r},\cdots,d_{j}$)。只要我们检查了所有可能的根结点 $k_r(i \leqslant r \leqslant j)$ ，并对每种情况分别求解包含 $k_i, \cdots, k_{r-1} $ 及包含 $k_{r+1}, \cdots, k_j $ 的最优二叉树，即可保证找到原问题的最优解。

这里有一个细节——空子树。假定对于包含关键字 $k_i, \cdots, k_j $ 的子问题，我们选定 $k_i$ 为根结点。根据前面论述，$k_i$ 的左子树就包含关键字 $k_i, \cdots, k_{i-1} $
。我们将此序列解释为不包含任何关键字。但子树中仍包含伪关键字。按照惯例，我们认为关键字 $k_i, \cdots, k_{i-1} $ 不包含任何关键字，但包含单一伪关键字 $d_{i-1}$。对称地，如果选择 $k_j$
作为根基点，那么它的右子树包含关键字 $k_{j+1},\dots,k_j$ ——此右子树不包含任何实际关键字，但包含伪关键字 $d_j$。

## 步骤2 一个递归算法

选取的子问题域：求解包含关键字 $k_i, \cdots, k_j $ 的最优二叉搜索树，其中 $i\geqslant 1,j \leqslant n 且 j \geqslant i-1$ (当 $j=i-1$
时，子树不包含实际的关键字，只包含伪关键字 $d_{i-1}$ )。定义 $e[i,j]$ 为在包含关键字 $k_i, \cdots, k_j $ 的最优二叉树中进行一次搜索的期望代价。最终希望计算出$e[1,n]$。

* 当将 $j = i-1$ 是，由于子树只包含了伪关键 $d_{i-1}$ ，期望搜索代价为 $e[i,i-1]=q_{i-1}$ 。

* 当 $j \geqslant i$ 时，从 $k_i, \cdots, k_j $ 选择一个结点作为根结点 $k_r$ ，然后构造一棵包含关键字 $k_i, \cdots, k_{r-1} $ 的最优二叉树作为其左子树，包含关键字$k_
  {r+1}, \cdots, k_{j} $ 的最优二叉树作为其右子树。当一棵树成为了一个结点在子树时，期望搜索代价如何变化？由于每个结点的深度都增加了1，根据公式(4.2），这颗子树的概率增加值应该为所有的概率之和。对于包含关键字
  $k_i, \cdots, k_{r-1} $ 的子树，所有的概率之和为 $$ w(i,j) = \sum \limits_{l=i}^{j} p_l + \sum\limits_{l=i}^{j}q_l \tag{4.3} $$

因此，若 $k_r$ 为包含关键字 $k_i,\cdots, k_j$ 的最优二叉搜索树的根结点，有如下公式 $$ e[i,j] = p_r + ((e[i,r-1] + w(i,r-1) + (e[r+1,j]+w(r+1,j))
\tag{4.4} $$ 由式(4.3)  $w(i,j) = w(i,r-1) + p_r + w(r+1,j)$

因此， $$ \begin{align} e[i,j] & = p_r + ((e[i,r-1] + w(i,r-1) + (e[r+1,j]+w(r+1,j))\\ &= e[i,r-1] + e[r+1,j] + w(i,j)
\tag{4.5} \end{align} $$ 递归公式（4.5）假定我们知道哪个结点 $k$ 应该作为根结点。如果选取期望代价最低者作为根结点，可得到下面的递推公式 $$ e[i,j] = \begin{cases} q_{i-1}
&,&j=i-1\\ \min \limits_{i \leqslant r \leqslant j}{ e[i,r-1] + e[r+1,j] + w(i,j)} &,&i \leqslant j  
\end{cases}\tag{4.6} $$ $e[i,j]$的值给出了最优二叉搜索树的期望搜索代价。为了记录二叉搜索树的结构，对于包含关键字 $k_i,\cdots,k_j(1\leqslant i \leqslant j
\leqslant n)$ 的最优二叉树，我们定义$root[i,j]$ 保存根结点 $k_r$ 的下表$r$。

## 步骤3 计算最优二叉搜索树的期望搜索代价

* 表 $e[1..n+1,0..n]$ 保存 $e[i,j]$ 的值，

    * 对于只包含伪关键字 $d_n$的子树， 用 $e[n+1,n]$ 保存。
    * 对于只包含伪关键字 $d_0$ 的子树，用 $e[1,0]$保存。

* 表 $root[i,j]，1 \leqslant i \leqslant j \leqslant n$ 记录包含关键字 $k_i, \cdots, k_j $ 的根。

* 表 $w[1..n+1,0..n]$ 保存 $w[i,j]$ ,避免每次计算 $e[i,j]$ 时重新计算 $w(i,j)$

    * $w[i,i-1] = q_{i-1}$
    * 对于 $j\geqslant i$ , $w[i,j] = w[i,j-1] + p_j + q_j \tag{4.7}$

  这样对于 $\Theta(n^2)$ 个 $w[i,j]$ ，每个计算的时间为 $\Theta(1)$ 。

* p 表示概率 $p_0,\cdots,p_n$

* q 表示概率 $q_0,\cdots, q_n$

* n 表示规模$n$

* 返回表e和root

```
OPTIMAL_BST(p,q,n):
	let e[1..n+1, 0..n], w[1..n+1, 0..n] and root[1..n, 1..n] be new tables
	for i = 1 to n+1
		e[i,i-1] = q[i-1]
		w[i,i-1] = q[i-1]
    for l= 1 to n
    	for i = 1 to n-l+1
    		j = i+l-1
    		e[i,j] = ∞
    		w[i,j] = w[i,j-1] + p[j] + q[j]
    		for r = i to j
    			t = e[i,r-1] + e[r+1,j] + w[i,j]
    			if t < e[i,j] 
    				e[i,j] = t
    				root[i,j] = r
	return e and root
```

 与MATRIT_CHAIN_ORDER复杂度一样，运行时间为 $\Theta(n^3)$

## 步骤4 构造而最优二叉树

```
Construct-OPTIMAL-BST(root)
```

# leetcode 题目

## 312. 戳气球

有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。
这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。 求所能获得硬币的最大数量。

```
示例 1：
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
示例 2：

输入：nums = [1,5]
输出：10

提示：

n == nums.length
1 <= n <= 300
0 <= nums[i] <= 100
```

* 思路分析

回溯方法复杂度过高

采用以下动态规划思路

这个动态规划问题和我们之前的动态规划系列文章相比有什么特别之处？为什么它比较难呢？

原因在于，这个问题中我们每戳破一个气球nums[i]，得到的分数和该气球相邻的气球nums[i-1]和nums[i+1]是有相关性的。 我们前文 动态规划套路框架详解
说过运用动态规划算法的一个重要条件：子问题必须独立。所以对于这个戳气球问题，如果想用动态规划，必须巧妙地定义dp数组的含义，避免子问题产生相关性，才能推出合理的状态转移方程。
如何定义dp数组呢，这里需要对问题进行一个简单地转化。题目说可以认为nums[-1] = nums[n] = 1，那么我们先直接把这两个边界加进去，形成一个新的数组points：

```
int maxCoins(int[]nums){
    int n=nums.length;
    // 两端加入两个虚拟气球
    int[]points=new int[n+2];
    points[0]=points[n+1]=1;
    for(int i=1;i<=n;i++){
      points[i]=nums[i-1];
    }
    // ...
}
```

现在气球的索引变成了从1到n，points[0]和points[n+1]可以认为是两个「虚拟气球」。

那么我们可以改变问题：在一排气球points中，请你戳破气球0和气球n+1之间的所有气球（不包括0和n+1），使得最终只剩下气球0和气球n+1两个气球，最多能够得到多少分？ 现在可以定义dp数组的含义： 
 `dp[i][j] = x` 表示，戳破气球i和气球j之间（开区间，不包括i和j）的所有气球，可以获得的最高分数为x。 那么根据这个定义，题目要求的结果就是`dp[0][n+1]`的值，而 base case 就是`dp[i][j] = 0，其中0 <= i <= n+1,
j <= i+1`，因为这种情况下，开区间(i, j)中间根本没有气球可以戳。 
// base case 已经都被初始化为 0 
`int[][] dp = new int[n + 2][n + 2];`
现在我们要根据这个dp数组来推导状态转移方程了，根据我们前文的套路，所谓的推导「状态转移方程」，实际上就是在思考怎么「做选择」，也就是这道题目最有技巧的部分：

不就是想求戳破气球i和气球j之间的最高分数吗，如果「正向思考」，就只能写出前文的回溯算法；我们需要「反向思考」，想一想气球i和气球j之间最后一个被戳破的气球可能是哪一个？

其实气球i和气球j之间的所有气球都可能是最后被戳破的那一个，不防假设为k。回顾动态规划的套路，这里其实已经找到了「状态」和「选择」：i和j就是两个「状态」，最后戳破的那个气球k就是「选择」。
根据刚才对dp数组的定义，如果最后一个戳破气球k，
`dp[i][j]` 的值应该为： 
`dp[i][j] = dp[i][k] + dp[k][j]`

+ points[i]*points[k]*points[j]
  你不是要最后戳破气球k吗？那得先把开区间(i, k)的气球都戳破，再把开区间(k, j)的气球都戳破；最后剩下的气球k，相邻的就是气球i和气球j，这时候戳破k的话得到的分数就是points[i]*points[k]*points[j]。
  那么戳破开区间(i, k)和开区间(k, j)的气球最多能得到的分数是多少呢？嘿嘿，就是dp[i][k]和dp[k][j]，这恰好就是我们对dp数组的定义嘛！

* 实现 leetcode.dp._312_戳气球
  ![img.png](戳气球复杂度.png)



## 486 预测赢家

![image-20220731110139987](动态规划/image-20220731110139987.png)

下文讲解时，认为元组是包含 `first` 和 `second` 属性的一个类，而且为了节省篇幅，将这两个属性简写为 `fir` 和 `sec`。比如按上图的数据，我们说 `dp[1][3].fir = 11`，`dp[0][1].sec = 2`。

先回答几个读者可能提出的问题：

这个二维 dp table 中存储的是元组，怎么编程表示呢？这个 dp table 有一半根本没用上，怎么优化？很简单，都不要管，先把解题的思路想明白了再谈也不迟。

**以下是对 dp 数组含义的解释：**

`dp[i][j].fir = x` 表示，对于 `piles[i...j]` 这部分石头堆，先手能获得的最高分数为 `x`。

`dp[i][j].sec = y` 表示，对于 `piles[i...j]` 这部分石头堆，后手能获得的最高分数为 `y`。

举例理解一下，假设 `piles = [2, 8, 3, 5]`，索引从 0 开始，那么：

`dp[0][1].fir = 8` 意味着：面对石头堆 `[2, 8]`，先手最多能够获得 8 分；`dp[1][3].sec = 5` 意味着：面对石头堆 `[8, 3, 5]`，后手最多能够获得 5 分。

我们想求的答案是先手和后手最终分数之差，按照这个定义也就是 `dp[0][n-1].fir - dp[0][n-1].sec`，即面对整个 `piles`，先手的最优得分和后手的最优得分之差。

### 二、状态转移方程

写状态转移方程很简单，首先要找到所有「状态」和每个状态可以做的「选择」，然后择优。

根据前面对 `dp` 数组的定义，**状态显然有三个：开始的索引 `i`，结束的索引 `j`，当前轮到的人。**

```python
dp[i][j][fir or sec]
其中：
0 <= i < piles.length
i <= j < piles.length
```

对于这个问题的每个状态，可以做的**选择有两个：选择最左边的那堆石头，或者选择最右边的那堆石头。** 我们可以这样穷举所有状态：

```python
n = piles.length
for 0 <= i < n:
    for j <= i < n:
        for who in {fir, sec}:
            dp[i][j][who] = max(left, right)
```

上面的伪码是动态规划的一个大致的框架，这道题的难点在于，两人足够聪明，而且是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？

根据我们对 `dp` 数组的定义，很容易解决这个难点，**写出状态转移方程：**

```python
dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)
dp[i][j].fir = max(     选择最左边的石头堆     ,     选择最右边的石头堆      )
# 解释：我作为先手，面对 piles[i...j] 时，有两种选择：
# 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j]
# 但是此时轮到对方，相当于我变成了后手；
# 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1]
# 但是此时轮到对方，相当于我变成了后手。

if 先手选择左边:
    dp[i][j].sec = dp[i+1][j].fir
if 先手选择右边:
    dp[i][j].sec = dp[i][j-1].fir
# 解释：我作为后手，要等先手先选择，有两种情况：
# 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]
# 此时轮到我，我变成了先手；
# 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]
# 此时轮到我，我变成了先手。
```

根据 dp 数组的定义，我们也可以找出 **base case**，也就是最简单的情况：

```python
dp[i][j].fir = piles[i]
dp[i][j].sec = 0
其中 0 <= i == j < n
# 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]
# 那么显然先手的得分为 piles[i]
# 后手没有石头拿了，得分为 0
```

![image-20220731110200056](动态规划/image-20220731110200056.png)



## 322 零钱兑换

![image-20220803155814400](动态规划/image-20220803155814400.png)



## 最长递增子序列（路径）

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

最长递增子序列（Longest Increasing Subsequence，简写 LIS）是非常经典的一个算法问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何找状态转移方程，如何写出动态规划解法。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。

力扣第 300 题「最长递增子序列」就是这个问题：

输入一个无序的整数数组，请你找到其中最长的严格递增子序列的长度，函数签名如下：

```
int lengthOfLIS(int[] nums);
```

比如说输入 `nums=[10,9,2,5,3,7,101,18]`，其中最长的递增子序列是 `[2,3,7,101]`，所以算法的输出应该是 4。

注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来设计动态规划算法解决这个问题。

#### 一、动态规划解法

动态规划的核心设计思想是数学归纳法。

相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么**我们先假设这个结论在 `k < n` 时成立，然后根据这个假设，想办法推导证明出 `k = n` 的时候此结论也成立**。如果能够证明出来，那么就说明这个结论对于 `k` 等于任何数都成立。

类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 `dp[0...i-1]` 都已经被算出来了，然后问自己：怎么通过这些结果算出 `dp[i]`？

直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 `dp[i]` 的值到底代表着什么？

**我们的定义是这样的：`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度**。

> PS：为什么这样定义呢？这是解决子序列问题的一个套路，后文 [动态规划之子序列问题解题模板](https://labuladong.github.io/article/fname.html?fname=子序列问题模板) 总结了几种常见套路。你读完本章所有的动态规划问题，就会发现 `dp` 数组的定义方法也就那几种。

根据这个定义，我们就可以推出 base case：`dp[i]` 初始值为 1，因为以 `nums[i]` 结尾的最长递增子序列起码要包含它自己。

举两个例子：

[![img](https://camo.githubusercontent.com/ed08292c49e50972338efde86ba2e4be2610b00530a4eedb5d8109a18e9109b1/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f382e6a706567)](https://camo.githubusercontent.com/ed08292c49e50972338efde86ba2e4be2610b00530a4eedb5d8109a18e9109b1/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f382e6a706567)

这个 GIF 展示了算法演进的过程：

[![img](https://camo.githubusercontent.com/0abffe778b24927ee8489f38c34202df5a29799afea39f2ea032c32c0498bb5e/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f676966312e676966)](https://camo.githubusercontent.com/0abffe778b24927ee8489f38c34202df5a29799afea39f2ea032c32c0498bb5e/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f676966312e676966)

根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。

```
int res = 0;
for (int i = 0; i < dp.length; i++) {
    res = Math.max(res, dp[i]);
}
return res;
```

读者也许会问，刚才的算法演进过程中每个 `dp[i]` 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 `dp[i]` 呢？

这就是动态规划的重头戏，如何设计算法逻辑进行状态转移，才能正确运行呢？这里需要使用数学归纳的思想：

**假设我们已经知道了 `dp[0..4]` 的所有结果，我们如何通过这些已知结果推出 `dp[5]` 呢**？

[![img](https://camo.githubusercontent.com/42ce5fa7f757d406be220a88f2061843e2f6a2b5ec49a4a276001c7ac4de2484/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f362e6a706567)](https://camo.githubusercontent.com/42ce5fa7f757d406be220a88f2061843e2f6a2b5ec49a4a276001c7ac4de2484/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f362e6a706567)

根据刚才我们对 `dp` 数组的定义，现在想求 `dp[5]` 的值，也就是想求以 `nums[5]` 为结尾的最长递增子序列。

**`nums[5] = 3`，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的子序列长度加一**。

`nums[5]` 前面有哪些元素小于 `nums[5]`？这个好算，用 for 循环比较一波就能把这些元素找出来。

以这些元素为结尾的最长递增子序列的长度是多少？回顾一下我们对 `dp` 数组的定义，它记录的正是以每个元素为末尾的最长递增子序列的长度。

以我们举的例子来说，`nums[0]` 和 `nums[4]` 都是小于 `nums[5]` 的，然后对比 `dp[0]` 和 `dp[4]` 的值，我们让 `nums[5]` 和更长的递增子序列结合，得出 `dp[5] = 3`：

[![img](https://camo.githubusercontent.com/02429b06aac49339cf34bf55db132d0fb925ad28e665b9e3c4973b25d2fe636f/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f372e6a706567)](https://camo.githubusercontent.com/02429b06aac49339cf34bf55db132d0fb925ad28e665b9e3c4973b25d2fe636f/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f372e6a706567)

```
for (int j = 0; j < i; j++) {
    if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
    }
}
```

当 `i = 5` 时，这段代码的逻辑就可以算出 `dp[5]`。其实到这里，这道算法题我们就基本做完了。

读者也许会问，我们刚才只是算了 `dp[5]` 呀，`dp[4]`, `dp[3]` 这些怎么算呢？类似数学归纳法，你已经可以算出 `dp[5]` 了，其他的就都可以算出来：

```
for (int i = 0; i < nums.length; i++) {
    for (int j = 0; j < i; j++) {
        // 寻找 nums[0..j-1] 中比 nums[i] 小的元素
        if (nums[i] > nums[j]) {
            // 把 nums[i] 接在后面，即可形成长度为 dp[j] + 1，
            // 且以 nums[i] 为结尾的递增子序列
            dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
}
```

结合我们刚才说的 base case，下面我们看一下完整代码：

```
int lengthOfLIS(int[] nums) {
    // 定义：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
    int[] dp = new int[nums.length];
    // base case：dp 数组全都初始化为 1
    Arrays.fill(dp, 1);
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) 
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
    
    int res = 0;
    for (int i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}
```

至此，这道题就解决了，时间复杂度 `O(N^2)`。总结一下如何找到动态规划的状态转移关系：

1、明确 `dp` 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

2、根据 `dp` 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。

目前的解法是标准的动态规划，但对最长递增子序列问题来说，这个解法不是最优的，可能无法通过所有测试用例了，下面讲讲更高效的解法。

#### 二、二分查找解法

这个解法的时间复杂度为 `O(NlogN)`，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。

根据题目的意思，我都很难想象这个问题竟然能和二分查找扯上关系。其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。

为了简单起见，后文跳过所有数学证明，通过一个简化的例子来理解一下算法思路。

首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。

[![img](https://camo.githubusercontent.com/acb9aedbf574272ee7a0d3838cc1a64d311a5eb92a9f9cbb37d57020967e6f18/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f706f6b6572312e6a706567)](https://camo.githubusercontent.com/acb9aedbf574272ee7a0d3838cc1a64d311a5eb92a9f9cbb37d57020967e6f18/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f706f6b6572312e6a706567)

**处理这些扑克牌要遵循以下规则**：

只能把点数小的牌压到点数比它大的牌上；如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。

比如说上述的扑克牌最终会被分成这样 5 堆（我们认为纸牌 A 的牌面是最大的，纸牌 2 的牌面是最小的）。

[![img](https://camo.githubusercontent.com/ca22db6ccad2968b2f546f3cb261e2957e91375d1bf40bc11e51d66df6af94bd/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f706f6b6572322e6a706567)](https://camo.githubusercontent.com/ca22db6ccad2968b2f546f3cb261e2957e91375d1bf40bc11e51d66df6af94bd/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f706f6b6572322e6a706567)

为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q），证明略。

[![img](https://camo.githubusercontent.com/5155438b454ebeb4f6b95e577ed63879ffad0b1e18b2774650e8493c056f3b20/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f706f6b6572332e6a706567)](https://camo.githubusercontent.com/5155438b454ebeb4f6b95e577ed63879ffad0b1e18b2774650e8493c056f3b20/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f706f6b6572332e6a706567)

按照上述规则执行，可以算出最长递增子序列，牌的堆数就是最长递增子序列的长度，证明略。

[![img](https://camo.githubusercontent.com/d93779cb49094735b5bb144710418f82130a93221980a9c587292e625f2ca3fc/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f706f6b6572342e6a706567)](https://camo.githubusercontent.com/d93779cb49094735b5bb144710418f82130a93221980a9c587292e625f2ca3fc/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545362539432538302545392539352542462545392538302539322545352541322539452545352541442539302545352542412538462545352538382539372f706f6b6572342e6a706567)

我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是**有序**吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。

> PS：前文 [二分查找算法详解](https://labuladong.github.io/article/fname.html?fname=二分查找详解) 详细介绍了二分查找的细节及变体，这里就完美应用上了，如果没读过强烈建议阅读。

```
int lengthOfLIS(int[] nums) {
    int[] top = new int[nums.length];
    // 牌堆数初始化为 0
    int piles = 0;
    for (int i = 0; i < nums.length; i++) {
        // 要处理的扑克牌
        int poker = nums[i];

        /***** 搜索左侧边界的二分查找 *****/
        int left = 0, right = piles;
        while (left < right) {
            int mid = (left + right) / 2;
            if (top[mid] > poker) {
                right = mid;
            } else if (top[mid] < poker) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        /*********************************/
        
        // 没找到合适的牌堆，新建一堆
        if (left == piles) piles++;
        // 把这张牌放到牌堆顶
        top[left] = poker;
    }
    // 牌堆数就是 LIS 长度
    return piles;
}
```

至此，二分查找的解法也讲解完毕。

这个解法确实很难想到。首先涉及数学证明，谁能想到按照这些规则执行，就能得到最长递增子序列呢？其次还有二分查找的运用，要是对二分查找的细节不清楚，给了思路也很难写对。

所以，这个方法作为思维拓展好了。但动态规划的设计方法应该完全理解：假设之前的答案已知，利用数学归纳的思想正确进行状态的推演转移，最终得到答案。

#### 三、拓展到二维

我们看一个经常出现在生活中的有趣问题，力扣第 354 题「俄罗斯套娃信封问题」，先看下题目：

[![img](https://camo.githubusercontent.com/e0520623878fa9a8a302d5602c68a8d21f49dd98fbe0579ac0b6a54e2be6e9aa/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545342542462541312545352542302538312545352542352538432545352541352539372f7469746c652e706e67)](https://camo.githubusercontent.com/e0520623878fa9a8a302d5602c68a8d21f49dd98fbe0579ac0b6a54e2be6e9aa/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545342542462541312545352542302538312545352542352538432545352541352539372f7469746c652e706e67)

**这道题目其实是最长递增子序列的一个变种，因为每次合法的嵌套是大的套小的，相当于在二维平面中找一个最长递增的子序列，其长度就是最多能嵌套的信封个数**。

前面说的标准 LIS 算法只能在一维数组中寻找最长子序列，而我们的信封是由 `(w, h)` 这样的二维数对形式表示的，如何把 LIS 算法运用过来呢？

[![img](https://camo.githubusercontent.com/d36195e75cbeb16e4dbe3b92ff0d22a267ba5e41e820988de94dffc33c0d45ed/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545342542462541312545352542302538312545352542352538432545352541352539372f302e6a7067)](https://camo.githubusercontent.com/d36195e75cbeb16e4dbe3b92ff0d22a267ba5e41e820988de94dffc33c0d45ed/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545342542462541312545352542302538312545352542352538432545352541352539372f302e6a7067)

读者也许会想，通过 `w × h` 计算面积，然后对面积进行标准的 LIS 算法。但是稍加思考就会发现这样不行，比如 `1 × 10` 大于 `3 × 3`，但是显然这样的两个信封是无法互相嵌套的。

这道题的解法比较巧妙：

**先对宽度 `w` 进行升序排序，如果遇到 `w` 相同的情况，则按照高度 `h` 降序排序；之后把所有的 `h` 作为一个数组，在这个数组上计算 LIS 的长度就是答案**。

画个图理解一下，先对这些数对进行排序：

[![img](https://camo.githubusercontent.com/feb1e63c6435d6ce6d264478fd04408b9c78cfd63d7d4e653611d5e27c2d996d/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545342542462541312545352542302538312545352542352538432545352541352539372f312e6a7067)](https://camo.githubusercontent.com/feb1e63c6435d6ce6d264478fd04408b9c78cfd63d7d4e653611d5e27c2d996d/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545342542462541312545352542302538312545352542352538432545352541352539372f312e6a7067)

然后在 `h` 上寻找最长递增子序列，这个子序列就是最优的嵌套方案：

[![img](https://camo.githubusercontent.com/a5a81784a0637a4bddbd48faff3add3b1fa8cd8468b3898bb4d8fa7f4f7c90e9/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545342542462541312545352542302538312545352542352538432545352541352539372f322e6a7067)](https://camo.githubusercontent.com/a5a81784a0637a4bddbd48faff3add3b1fa8cd8468b3898bb4d8fa7f4f7c90e9/68747470733a2f2f6c6162756c61646f6e672e6769746875622e696f2f616c676f2f696d616765732f2545342542462541312545352542302538312545352542352538432545352541352539372f322e6a7067)

为什么呢？稍微思考一下就明白了：

首先，对宽度 `w` 从小到大排序，确保了 `w` 这个维度可以互相嵌套，所以我们只需要专注高度 `h` 这个维度能够互相嵌套即可。

其次，两个 `w` 相同的信封不能相互包含，所以对于宽度 `w` 相同的信封，对高度 `h` 进行降序排序，保证 LIS 中不存在多个 `w` 相同的信封（因为题目说了长宽相同也无法嵌套）。

下面看解法代码：

```
// envelopes = [[w, h], [w, h]...]
public int maxEnvelopes(int[][] envelopes) {
    int n = envelopes.length;
    // 按宽度升序排列，如果宽度一样，则按高度降序排列
    Arrays.sort(envelopes, new Comparator<int[]>() 
    {
        public int compare(int[] a, int[] b) {
            return a[0] == b[0] ? 
                b[1] - a[1] : a[0] - b[0];
        }
    });
    // 对高度数组寻找 LIS
    int[] height = new int[n];
    for (int i = 0; i < n; i++)
        height[i] = envelopes[i][1];

    return lengthOfLIS(height);
}

int lengthOfLIS(int[] nums) {
    // 见前文
}
```

为了清晰，我将代码分为了两个函数， 你也可以合并，这样可以节省下 `height` 数组的空间。

由于增加了测试用例，这里必须使用二分搜索版的 `lengthOfLIS` 函数才能通过所有测试用例。这样的话算法的时间复杂度为 `O(NlogN)`，因为排序和计算 LIS 各需要 `O(NlogN)` 的时间，加到一起还是 `O(NlogN)`；空间复杂度为 `O(N)`，因为计算 LIS 的函数中需要一个 `top` 数组。