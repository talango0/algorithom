[TOC]

# 一、基本图的算法
## 1.1. 图的表示

## 1.2. 广度优先搜索

## 1.3. 深度优先搜索

## 1.4. 拓扑排序

## 1.5. 强连通分量

# 二、最小生成树
## 2.1. 最小生成树的形成

## 2.2. Kruskal 算法和 Prim 算法

# 三、单源最短路径
最短路径
最直观的图处理问题就是导航软件获取一个地方到另一个地方的路径。对应的图模型：顶点对应交叉路口，边对应公路，边的权重对应经过该路段对应的成本（时间或距离），如果有单行线，那就意味着还需要考虑加权有向图。
问题容易归纳为：
找到从一个顶点到达另一个顶点的成本最小的路径。
一般性的模型，即*加权有向图*，定义： 在一个加权有向图中，从顶点 s 到 t 的**最短路径**是所有从 s 到 t 的路径中的权重最小值。

**最短路径树**
给定一副加权有向图的一个顶点 s， 以 s 为起点的一颗*最短路径树*是图的一副子图，它包含 s 和 从 s 可达的所有顶点。这颗有向树的根结点为 s， 树的每条路径都是有向图中的一条最短路径。

**松弛操作（Relaxation）**
对于一个结点 v 来说，维持一个属性 $v.d$， 用于记录从源结点 s 结点 v 的最短路径的上界。我们称 $v.d$ 为 s 到 v 的*最短路径估计*。运用下面的算法进行初始化：

```tex
INITIALIZE-SINGLE-SOURCE(G, s):
    for each vertex in v ∈ G.V :
        v.d = ∞
        v.pi = NIL
    s.d = 0
```



对一条边的(u, v)的relaxation过程为：

```markdown
RELAX(u, v, w):
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.π = u   
```


本章的每个算法都会调用 INITIALIZE-SINGLE-SOURCE(G, s)， 然后对边进行 RELAX(u, v, w)。而且 RELAX 过程是唯一导致最短路径估计和前驱结点发生变化的过程。本章所讨论的所有算法之间的不同之处是对每条边的次序有所不同。
Dijkstra 算法和用于有向无环图的最短路径算法对每条边仅松弛一次。Bellman-Ford 算法则对每条边松弛 $｜V-1|$ 次。

最短路径和松弛操作的性质：
**三角不等式性质** 
对于任何边 $(u, v) \in e \leqslant \delta(s, u) + w(u, v)$ 。
**上界性质**
对于所有结点 $v \in V$ 总有 $v.d \geqslant \delta(s, v)$ ，一旦 $v.d$ 达到 $\delta(s, v)$ ，其值不再变化。
**非路径性质**
如果从 s 到 v 不存在路径。则总有 $v.d=\delta(s,v)=\infty $。

**收敛性质**

对于某些结点 $ v，v \in V$ 如果 $s \leadsto u \rightarrow v$ 是图 $G$ 的一条最短路径，并且在对边 $（u，v）$ 进行松弛前的任意时间有 $u.d=\delta(s,u)$ 则在之后的所有时间有 $v.d=\delta(s, u)$ 。

**路径松弛性质**
如果 $p=<v_0, v_1, ... , v_k>$ 是从 $v=v_0$ 到结点 $v_k$ 的最短路径，并且我们对 $p$ 中的边所进行松弛的次序为 $（v_0, v_1）,(v_1, v_2), ... , (v_{k-1}, v_k)$ ，则 $v_k.d=\delta(s, v_k)$。该性质的成立与任何其他的松弛操作无关，即使这些松弛操作是与对 $p$ 上的变所进行的松弛操作穿插进行的。

**前驱子图性质**

对于所有的结点 $v\in V$, 一旦 $v.d=\delta(s, v)$， 则前驱子图是以根结点为 $s$ 的最短路径树。

## 3.1. Bellman-Ford 算法

Bellman-Ford 解决一般情况下的单源最短路径，边的权重可以为负的。给定带权重的有向图 $G=(V,E)$ 和权重函数 $w： E \rightarrow R$ ,Bellman-Ford 返回一个布尔值，已表明是否存在一个用源结点可以到达的权重为负的环路。如果存在这样的一个环路，算法将告诉我们不存在解决方案。如果没有这种环路存在，算法将给出最短路径和它们的权重。

```markdown
BELLMAN_FORD(G, w, s)
	INITIALIZE-SINGLE-SOURCE(G, s)
	for i = 1 to G.V - 1
		for each edge(u,v) in G.E
			RELAX(u, v, w)
	for each edge(u,v) ∈ G.E
		if v.d > u.d + w(u,v)
			return FALSE
	return TRUE
```

算法复杂度分析：初始化需要的时间是 $\Theta(V)$ ，第一个 for循环需要执行 $｜V｜-1$ ，每个里面的 for循环需要执行 $\Theta(E)$。Bellman-Ford 总运行时间为 $O(VE)$ 。

## 3.2. 有向无环图中的单源最短路径

根据结点的拓扑排序次序来对带权重的有向无环图 $G=（V，E）$进行边的松弛操作，我们便可以在 $\Theta(V+E)$ 时间内计算出从单个源结点到所结点之间的最短路径。在有向无环图中，即使存在权重为负的边，但因为没有权重为负的环路，最短路径都是存在的。

```markdown
DAG-SHORTEST-PATHS(G, w, s)
	topologically sort the vertices of G
	INITIALIZE-SINGLE-SOURCE(G, s)
	for each vertex u, taken in topologically sorted order
		for each vertex v ∈ G.Adj[u]
			RELAX(u, v, w)
```

算法运行时间复杂度分析。拓扑排序的时间为 $\Theta(V+E)$ 。INITIALIZE-SINGLE-SOURCE(G, s)调用的时间为 $\Theta(V)$。第一个for循环对于每个结点都执行一次。因为内循环每次的运行时间为 $\Theta(1)$ 。算法总运行时间为 $\Theta(V+E)$ 。对于以邻接链表法表示的图来说，这个时间是线性级别。

定理：如果带权重无环路的有向图 $G=（V,E）$ 有一个源结点 $s$ ，则算法 DAG-SHORTEST-PATHS(G, w, s) 终止时，对于所有结点 $v \in V$，我们有 $v.d=\delta(s,v)$ ,且前驱子图 $G_\pi$ 是一颗最短路径树。

## 3.3. Dijkstra 算法

DijKstra 算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。因此本节讨论的中，假定对于所有的边 $(u，v) \in E $, 都有 $(u,v) \geqslant 0$ 。如果采用实现方式合适，Dijkstra 算法的运行时间低于 Bellman-Ford 算法的运行时间。

Dijkstra 算法在运行过程中维持的关键信息是一组结点集合 $S$ 。从源结点 $s$ 到该集合中每个结点之间的最短路径已经被找到。算法重复从结点集 $V-S$ 中选择最短路径估计最小的结点 $u$， 将 $u$ 加入到集合中 $S$，然后对所有从 $u$ 发出的边进行松弛。在下面给出的实现方式中过，我们使用一个最小优先队列$Q$ 来保存结点结婚，每个结点的关键值为其$d$值。

```markdown
DIJKSTRA(G, w, s)
	INITIALIZE-SINGLE-SOURCE(G, s)
	S = ∅
	Q = G.V
	while Q ≠ S
		u = EXTRACT-MIN(Q)
		S = S ∪ {u}
		for each vertex v ∈ G.Adj[u]
		RELAX(u, v, w)	
```



## 3.4. 差分约束和最短路径
## 3.5. 最短路径性质的证明
### 3.5.1. 三角不等式性质
### 3.5.2. 最短路径估计值的松弛效果
### 3.5.3. 松弛操作与最短路径树

# 四、所有结点对的最短路径问题

我们给出*邻接矩阵*表示的一些约定。首先，假定输入图 $G=(V,E)$ 有 $n$ 个结点，因此 $n=｜V｜$。其次，我们使用大写字母表示矩阵，如 $W、L$ 和 $D$，用带下标的小写字母表示矩阵中的某个元素，如 $w_{ij}, L_{ij}$ 或 $D_{ij}$ 。将 $L^{m}=(l^{\small(m)}_{\small ij})$ 或 $(D^{m} = d^{\small(m)}_{\small ij})$ 用来表示迭代。最后，对于一个给定的 $n \times n$ 矩阵 $A$ ，假定矩阵的维度 $n$ 存储在属性 $A.rows$ 中。

## 4.1. 最短路径和矩阵乘法
## 4.2. Floyed-Warshall 算法
## 4.3. 用于稀疏图的 Johnson 算法

# 五、最大流

## 5.1. 流网络

给出流网络的图论定义，讨论其性质，并精确地定义最大流问题。

### 流网络和流

**流网络** $G=(V,E)$ 是一个有向图，图中每条边 $(u,v) \in E$ 有一个非负的 **容量值** $c(u,v) \geqslant 0$ 。而且，如果边集合$E$包含一条边$（u,v）$  ，则图中不存在反方向的边 $(v,u)$ 。如果 $(u,v) \notin E$ ，则为了方便起见，定义 $c(u,v)=0$，并且在图中不允许自循环。在流网络的所以结点中，我们特别地辨别出两个特殊结点：**源结点** $s$ 和**汇结点** $t$。为方便起见，假定每个结点都在从源结点到汇点的某个路径上。也就是说，对于每个结点 $v \in V$，流网络都包含一条路径，$s \leadsto v \leadsto t $。因此，流网络是连通的，并且由于初源结点外的每个结点都至少有一条进入的边，我们有 $｜E｜ \geqslant |V|-1$。

流的形式化定义。设 $G=(V,E)$ 为一个流网路，其容量函数为 $c$ 。设 $s$ 为网络的源结点，$t$ 为网络的汇点。$G$ 中的流是一个实值函数 $f:V \times V \rightarrow R$，满足下面的两条性质：

* 容量限制：对于所有的结点 $v，v \in V$ ，要求 $0 \leqslant f(u,v) \leqslant c(u,v)$。

* 流量守恒：对于所有的结点 $u \in V-\{s,t\}$ ,要求
  $$
  \sum_{v \in V}f(v,u) = \sum_{v \in V} f(u,v)
  $$
  当$(u,v)\notin E$时，从结点 $u$ 到结点 $v$ 之间没有流，因此 $f(u,v)=0$

  我们称非负数值 $f(u,v)$ 从结点 $u$ 到结点 $v$ 的流。一个流 $f$ 的值 $｜f｜$ 定义如下：
  $$
  ｜f｜ = \sum_{v\in V} f(s,v) - \sum_{v \in V}f(v,s)
  $$
  也就是说，流 $f$ 的值是从源结点流出的总流量减去流入源结点的总流量。（这里的 $｜\bullet｜$表示流的值，而不是绝对值或者基数值。）通常来说，一个流网络不会有任务进入源结点的边，因此，公式中的 $ \sum_{v \in V}f(v,s)$ 将是0，我们在公示中囊括在该公式的原因在于后面要讨论残存网络，这种网络中，流入源结点的流量十分重要。在最大流问题中，给定一个流网络$G$ 、一个源结点 $s$ 、一个汇点 $t$ ，我们希望找到值最大的一个流。

  容量限制说明从一个结点到另一个结点之间的流必须为非负值，且不能超过给定的容量限额。流量守恒说明，流入一个结点（指非源结点和非汇点）的总流量必须等于流出该结点的总流量，非形式化地称为“流入等于流出”。
  
  

## 5.2. Ford-Fulkerson方法

Ford-Fulkerson方法依赖三种重要思想，它们与许多流算法和问题有关，如 *残存网络、增广路径、切割*。 这些想法是最大流最小切割定理的精髓，该定理以流网络的切割来表述最大流的值。

Ford-Fulkerson 方法循环增加流的值。在开始的时候，对所有的结点 $v,v \in V,f(u,v) =0$ ，给出的初始流值为0。在每一次迭代中，我们将图 $G$ 的流值进行增加，方法就是在一个关联的“残存网络” $G_f$ 中寻找一条“增广路径”。一旦知道图 $G_f$ 中的一条增广路径的边，就可以很容易辨别出 $G$ 中的一些具体的边，我们可以对这些边上的流量进行修改，从而增加流的值。虽然 Ford-Fulkerson 方法每次迭代都增加流的值，但是对于图 $G$ 的一条特定边来说，其流量可能增加，也可能减少；对某些边的流进行所见可能是必要的，以便让算法可以将更多的流从源结点发送到汇点。重复对流进行这一过程，知道残存网络中不再存在增广路径为止。最大流最小切割定理说明在算法终结时，该算法将获得一个最大流。

```tex
FORD-FULKERSON-METHOD(G, s, t)
	initialize flow f to 0
	while there exists an augmenting path p in residual network G_f
		augment flow f along p
	return f
```

为了实现和分析 Ford-Fulkerson方法，需要引入以下几个新概念。

### 残存网络

### 增广路径

### 流网络的切割

最大流最小切割定理，设 $f$ 为流网络 $G=(V,E)$ 中的一个流，该留网络的源结点为 $s$ ，汇点为 $t$，则下面的条件是等价的：

1. $f$ 是 $G$ 的一个最大流。
2. 残存网络 $G_f$ 不包括任何增广路径。
3. $｜f｜=c(S,T)$，其中 $(S,T)$ 是流网络 $G$ 的某个切割。

### 基本的 Ford-Fulkerson算法

### Edmonds-Karp算法

## 5.3. 最大二分匹配

### **最大二分匹配问题**

### **寻找最大二分匹配**

## 5.4. 推送-重贴标签算法
## 5.5. 前置重贴标签算法

