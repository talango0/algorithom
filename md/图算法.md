[TOC]

# 一、基本图的算法
## 1.1. 图的表示

## 1.2. 广度优先搜索

## 1.3. 深度优先搜索

## 1.4. 拓扑排序

## 1.5. 强连通分量

# 二、最小生成树
## 2.1. 最小生成树的形成

## 2.2. Kruskal 算法和 Prim 算法

# 三、单源最短路径
最短路径
最直观的图处理问题就是导航软件获取一个地方到另一个地方的路径。对应的图模型：顶点对应交叉路口，边对应公路，边的权重对应经过该路段对应的成本（时间或距离），如果有单行线，那就意味着还需要考虑加权有向图。
问题容易归纳为：
找到从一个顶点到达另一个顶点的成本最小的路径。
一般性的模型，即*加权有向图*，定义： 在一个加权有向图中，从顶点 s 到 t 的**最短路径**是所有从 s 到 t 的路径中的权重最小值。

**最短路径树**
给定一副加权有向图的一个顶点 s， 以 s 为起点的一颗*最短路径树*是图的一副子图，它包含 s 和 从 s 可达的所有顶点。这颗有向树的根结点为 s， 树的每条路径都是有向图中的一条最短路径。

**松弛操作（Relaxation）**
对于一个结点 v 来说，维持一个属性 $v.d$， 用于记录从源结点 s 结点 v 的最短路径的上界。我们称 $v.d$ 为 s 到 v 的*最短路径估计*。运用下面的算法进行初始化：

```tex
INITIALIZE-SINGLE-SOURCE(G, s):
    for each vertex in v ∈ G.V :
        v.d = ∞
        v.pi = NIL
    s.d = 0
```



对一条边的(u, v)的relaxation过程为：

```markdown
RELAX(u, v, w):
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.π = u   
```


本章的每个算法都会调用 INITIALIZE-SINGLE-SOURCE(G, s)， 然后对边进行 RELAX(u, v, w)。而且 RELAX 过程是唯一导致最短路径估计和前驱结点发生变化的过程。本章所讨论的所有算法之间的不同之处是对每条边的次序有所不同。
Dijkstra 算法和用于有向无环图的最短路径算法对每条边仅松弛一次。Bellman-Ford 算法则对每条边松弛 $｜V-1|$ 次。

最短路径和松弛操作的性质：
**三角不等式性质** 
对于任何边 $(u, v) \in e \leqslant \delta(s, u) + w(u, v)$ 。
**上界性质**
对于所有结点 $v \in V$ 总有 $v.d \geqslant \delta(s, v)$ ，一旦 $v.d$ 达到 $\delta(s, v)$ ，其值不再变化。
**非路径性质**
如果从 s 到 v 不存在路径。则总有 $v.d=\delta(s,v)=\infty $。

**收敛性质**

对于某些结点 $ v，v \in V$ 如果 $s \leadsto u \rightarrow v$ 是图 $G$ 的一条最短路径，并且在对边 $（u，v）$ 进行松弛前的任意时间有 $u.d=\delta(s,u)$ 则在之后的所有时间有 $v.d=\delta(s, u)$ 。

**路径松弛性质**
如果 $p=<v_0, v_1, ... , v_k>$ 是从 $v=v_0$ 到结点 $v_k$ 的最短路径，并且我们对 $p$ 中的边所进行松弛的次序为 $（v_0, v_1）,(v_1, v_2), ... , (v_{k-1}, v_k)$ ，则 $v_k.d=\delta(s, v_k)$。该性质的成立与任何其他的松弛操作无关，即使这些松弛操作是与对 $p$ 上的变所进行的松弛操作穿插进行的。

**前驱子图性质**

对于所有的结点 $v\in V$, 一旦 $v.d=\delta(s, v)$， 则前驱子图是以根结点为 $s$ 的最短路径树。

## 3.1. Bellman-Ford 算法

Bellman-Ford 解决一般情况下的单源最短路径，边的权重可以为负的。给定带权重的有向图 $G=(V,E)$ 和权重函数 $w： E \rightarrow R$ ,Bellman-Ford 返回一个布尔值，已表明是否存在一个用源结点可以到达的权重为负的环路。如果存在这样的一个环路，算法将告诉我们不存在解决方案。如果没有这种环路存在，算法将给出最短路径和它们的权重。

```markdown
BELLMAN_FORD(G, w, s)
	INITIALIZE-SINGLE-SOURCE(G, s)
	for i = 1 to G.V - 1
		for each edge(u,v) in G.E
			RELAX(u, v, w)
	for each edge(u,v) ∈ G.E
		if v.d > u.d + w(u,v)
			return FALSE
	return TRUE
```

算法复杂度分析：初始化需要的时间是 $\Theta(V)$ ，第一个 for循环需要执行 $｜V｜-1$ ，每个里面的 for循环需要执行 $\Theta(E)$。Bellman-Ford 总运行时间为 $O(VE)$ 。

## 3.2. 有向无环图中的单源最短路径

根据结点的拓扑排序次序来对带权重的有向无环图 $G=（V，E）$进行边的松弛操作，我们便可以在 $\Theta(V+E)$ 时间内计算出从单个源结点到所结点之间的最短路径。在有向无环图中，即使存在权重为负的边，但因为没有权重为负的环路，最短路径都是存在的。

```markdown
DAG-SHORTEST-PATHS(G, w, s)
	topologically sort the vertices of G
	INITIALIZE-SINGLE-SOURCE(G, s)
	for each vertex u, taken in topologically sorted order
		for each vertex v ∈ G.Adj[u]
			RELAX(u, v, w)
```

算法运行时间复杂度分析。拓扑排序的时间为 $\Theta(V+E)$ 。INITIALIZE-SINGLE-SOURCE(G, s)调用的时间为 $\Theta(V)$。第一个for循环对于每个结点都执行一次。因为内循环每次的运行时间为 $\Theta(1)$ 。算法总运行时间为 $\Theta(V+E)$ 。对于以邻接链表法表示的图来说，这个时间是线性级别。

定理：如果带权重无环路的有向图 $G=（V,E）$ 有一个源结点 $s$ ，则算法 DAG-SHORTEST-PATHS(G, w, s) 终止时，对于所有结点 $v \in V$，我们有 $v.d=\delta(s,v)$ ,且前驱子图 $G_\pi$ 是一颗最短路径树。

## 3.3. Dijkstra 算法

DijKstra 算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。因此本节讨论的中，假定对于所有的边 $(u，v) \in E $, 都有 $(u,v) \geqslant 0$ 。如果采用实现方式合适，Dijkstra 算法的运行时间低于 Bellman-Ford 算法的运行时间。

Dijkstra 算法在运行过程中维持的关键信息是一组结点集合 $S$ 。从源结点 $s$ 到该集合中每个结点之间的最短路径已经被找到。算法重复从结点集 $V-S$ 中选择最短路径估计最小的结点 $u$， 将 $u$ 加入到集合中 $S$，然后对所有从 $u$ 发出的边进行松弛。在下面给出的实现方式中过，我们使用一个最小优先队列$Q$ 来保存结点结婚，每个结点的关键值为其$d$值。

```markdown
DIJKSTRA(G, w, s)
	INITIALIZE-SINGLE-SOURCE(G, s)
	S = ∅
	Q = G.V
	while Q ≠ S
		u = EXTRACT-MIN(Q)
		S = S ∪ {u}
		for each vertex v ∈ G.Adj[u]
		RELAX(u, v, w)	
```



## 3.4. 差分约束和最短路径
## 3.5. 最短路径性质的证明
### 3.5.1. 三角不等式性质
### 3.5.2. 最短路径估计值的松弛效果
### 3.5.3. 松弛操作与最短路径树

# 四、所有结点对的最短路径问题

我们给出*邻接矩阵*表示的一些约定。首先，假定输入图 $G=(V,E)$ 有 $n$ 个结点，因此 $n=｜V｜$。其次，我们使用大写字母表示矩阵，如 $W、L$ 和 $D$，用带下标的小写字母表示矩阵中的某个元素，如 $w_{ij}, L_{ij}$ 或 $D_{ij}$ 。将 $L^{m}=(l^{\small(m)}_{\small ij})$ 或 $(D^{m} = d^{\small(m)}_{\small ij})$ 用来表示迭代。最后，对于一个给定的 $n \times n$ 矩阵 $A$ ，假定矩阵的维度 $n$ 存储在属性 $A.rows$ 中。

## 4.1. 最短路径和矩阵乘法
## 4.2. Floyed-Warshall 算法
## 4.3. 用于稀疏图的 Johnson 算法

# 五、最大流
## 5.1. 流网络
## 5.2. Ford-Fulerson 方法
## 5.3. 最大二分匹配
## 5.4. 推送-重贴标签算法
## 5.5. 前置重贴标签算法